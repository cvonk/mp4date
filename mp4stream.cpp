/* mp4stream.cpp : network byte order layer on top of fstream for use with mp4 files
 * Coert Vonk, in part based on
 *   https://github.com/macmade/MP4Parse
 *   for license see block below
 *
 * (c) Copyright 2015 by Coert Vonk - coertvonk.com
 * Boost Sofware License 1.0, see below
 * All rights reserved.  Use of copyright notice does not imply publication.
 */

/*******************************************************************************
 * 
 * Copyright (c) 2011, Jean-David Gadina - www.xs-labs.com
 * Distributed under the Boost Software License, Version 1.0.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 *  works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/

/* $Id$ */

#include "stdafx.h"
#include <stdint.h>
#include <fstream>
#include <iostream>
#include "mp4stream.h"

mp4StreamException::mp4StreamException( void )
{
    this->code = -1;
}

mp4StreamException::mp4StreamException( unsigned int c )
{
    this->code = c;
}

const char *
mp4StreamException::what( void ) const throw()
{
    switch ( this->code ) {
        case mp4StreamException::NoFileName:
            return "No input file";
        case mp4StreamException::OpenError:
            return "File open error";
    }
    return "Unknown exception";
}

mp4Stream::mp4Stream( void )
{
    mp4StreamException e = mp4StreamException( mp4StreamException::NoFileName );

    throw e;
}

mp4Stream::mp4Stream( char * filename )
{
    this->stream.open( filename, std::ios::binary | std::ios::in | std::ios::out );

    if ( this->stream.is_open() == false || this->stream.good() == false ) {
        mp4StreamException e = mp4StreamException( mp4StreamException::OpenError );

        throw e;
    }
}

mp4Stream::~mp4Stream( void )
{
    if ( this->stream.is_open() ) {
        this->stream.close();
    }
}


uint8_t
mp4Stream::readUint8( void )
{
    uint8_t n;
    this->read( (char *)&n, 1 );

    return n;
}

uint32_t
mp4Stream::readUint16( void )
{
    uint8_t  c[2];
    this->read( (char *)c, 2 );

    uint16_t const n = (uint16_t)c[0] << 8 |
                       (uint16_t)c[1];
    return n;
}

uint32_t
mp4Stream::readUint32( void )
{
    uint8_t  c[4];
    this->read( (char *)c, 4 );

    uint32_t const n = (uint32_t)c[0] << 24 |
                       (uint32_t)c[1] << 16 |
                       (uint32_t)c[2] <<  8 |
                       (uint32_t)c[3];
    return n;
}

uint64_t
mp4Stream::readUint64( void )
{
    uint8_t  c[8];
    uint64_t n;

    this->read( (char *)c, 8 );

    n = (uint64_t)c[0] << 56 |
        (uint64_t)c[1] << 48 |
        (uint64_t)c[2] << 40 |
        (uint64_t)c[3] << 32 |
        (uint64_t)c[4] << 24 |
        (uint64_t)c[5] << 16 |
        (uint64_t)c[6] << 8 |
        (uint64_t)c[7];

    return n;
}

std::ostream &
mp4Stream::writeUint8( uint8_t const value )
{
    return this->write( (char *)value, 1 );
}

std::ostream &
mp4Stream::writeUint16( uint16_t const value )
{
    uint8_t  c[2];
    c[0] = (uint8_t)((value & 0xFF00U) >> 8);
    c[1] = (uint8_t)((value & 0x00FFU) >> 0);

    return this->write( (char *)c, 2 );
}


std::ostream &
mp4Stream::writeUint32( uint32_t const value  )
{
    uint8_t  c[4];
    c[0] = (uint8_t)((value & 0xFF000000U) >> 24);
    c[1] = (uint8_t)((value & 0x00FF0000U) >> 16);
    c[2] = (uint8_t)((value & 0x0000FF00U) >>  8);
    c[3] = (uint8_t)((value & 0x000000FFU) >>  0);

    return this->write( (char *)c, 4 );
}

std::ostream &
mp4Stream::writeUint64( uint64_t const value )
{
    uint8_t  c[8];
    c[0] = (uint8_t)((value & 0xFF00000000000000LU) >> 56);
    c[1] = (uint8_t)((value & 0x00FF000000000000LU) >> 48);
    c[2] = (uint8_t)((value & 0x0000FF0000000000LU) >> 40);
    c[3] = (uint8_t)((value & 0x000000FF00000000LU) >> 32);
    c[4] = (uint8_t)((value & 0x00000000FF000000LU) >> 24);
    c[5] = (uint8_t)((value & 0x0000000000FF0000LU) >> 16);
    c[6] = (uint8_t)((value & 0x000000000000FF00LU) >>  8);
    c[7] = (uint8_t)((value & 0x00000000000000FFLU) >>  0);

    return this->write( (char *)c, 8 );
}

bool
mp4Stream::good( void ) const
{
    return stream.good();
}

bool
mp4Stream::eof( void ) const
{
    return stream.eof();
}

bool
mp4Stream::fail( void ) const
{
    return stream.fail();
}

bool
mp4Stream::bad( void ) const
{
    return stream.bad();
}

int
mp4Stream::peek( void )
{
    return stream.peek();
}

int
mp4Stream::get( void )
{
    return stream.get();
}

int
mp4Stream::sync( void )
{
    return stream.sync();
}

std::streampos
mp4Stream::tellg( void )
{
    return stream.tellg();
}

std::streampos
mp4Stream::tellp( void )
{
    return stream.tellp();
}

std::istream & 
mp4Stream::ignore( std::streamsize n, int delim )
{
    return stream.ignore( n, delim );
}

std::istream & 
mp4Stream::read( char * s, std::streamsize n )
{
    return stream.read( s, n );
}

std::istream & 
mp4Stream::putback( char c )
{
    return stream.putback( c );
}

std::istream & 
mp4Stream::unget( void )
{
    return stream.unget();
}

std::istream & 
mp4Stream::seekg( std::streampos pos )
{
    return stream.seekg( pos );
}

std::istream & 
mp4Stream::seekg( std::streamoff off, std::ios_base::seekdir dir )
{
    return stream.seekg( off, dir );
}

std::ostream & 
mp4Stream::seekp( std::streampos pos )
{
    return stream.seekp( pos );
}

std::ostream & 
mp4Stream::seekp( std::streamoff off, std::ios_base::seekdir dir )
{
    return stream.seekp( off, dir );
}

std::ostream & 
mp4Stream::write( char * s, std::streamsize n )
{
    return stream.write( s, n );
}
